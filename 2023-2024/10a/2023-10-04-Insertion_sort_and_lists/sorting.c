#include <stdio.h>
#include "../utils/vector.h"

/*
    В часа направихме сравнение и анализ на двата алгоритъма. В алгоритмите за сортиране, които ще разглеждаме основните
    операции, от които се интересуваме са сравнение и размени на елементи. С N бележим големината на масива

    На кратко, започвайки от selectionSort, понеже е по-лесен.
    Ако се замислим ще забележим, че SelectionSort работи по напълно един и същи начин при всички масиви с еднаква големина.
    Тоест винаги ще се изпълнят едни и същи сравнение и размени. Това не е така при други алгоритми, например Bubble Sort.
    При него в зависимост от подредбата ще се извършат различни размени. При SelectionSort началната конфигурация на масива няма значение.
    Във вътрешния цикъл винаги ще се изпълнят N - j сравнение и след него 1 размяна независимо какви са елементите на масива.
    В комбинация със външния цикъл това това са (N + (N - 1) + (N - 2) ... + 1) сравнения и N размени. Първия израз е сума на числата
    от 1 до N, което знаем, че е равно на N*(N + 1)/2 . Ще обсъдим по-подробно следващите часове, но за момента просто ще приемем, че
    от значение е само най-високата степен на израза, тоест N^2.
    Накрая получихме, че SelectionSort винаги извършва N размени и от порядъка на N^2 сравнение. Общо N^2 + N операции. Отново тук ни
    интересува само най-високата степен и можем да заключим, че SelectionSort извършва от порядъка на N^2 операции.
*/

void SelectionSort(vector_t *v)
{
    /*
        Вътрешният цикъл служи за намиране на най-малкия елемент. Важно е на всяка итерация
        да задаваме смислени начални стойности за min и minIndex, иначе алгоритъмът не би работил коректно.
    */
    for (int j = 0; j < getSize(v); j++)
    {
        int min = getAt(v, j);
        int minIndex = j;
        for (int i = j; i < getSize(v); i++)
        {
            if (getAt(v, i) < min)
            {
                min = getAt(v, i);
                minIndex = i;
            }
        }

        int tmp = getAt(v, j);
        v->arr[j] = v->arr[minIndex];
        v->arr[minIndex] = tmp;
    }
}

/*
    При InsertionSort анализът е малко по-сложен понеже тук не винаги се случва едно и също. Вътрешният цикъл може да приключи по-рано в зависимост
    от началната подребна на елементите. Например, ако масивът е вече сортиран, то вътрешният цикъл ще приключва веднага и алгоритъм ще завърши бързо.
    На практика, обаче това едва ли ще се случва често. И това ще обсъдим по-подорбно в следващите часове, но за момента може да кажем, че
    при анализ на алгоритъм ние най-вече се интересуваме от тяхната бързина в най-лошия случай, а не в най-добрия. При InsertionSort
    най-лош случай би бил масивът да е сортиран, но наобратно. Тогава вътрешният цикъл ще трябва да се извърта до край всеки път.
    Аналогично на SelectionSort тук ще има N^2 сравнение, но и N^2 записа понеже във вътрешния цикъл освен сравнение винаги става и
    изместване на елемент в дясно. В такъв случай, на пръв поглед бихме си казали, че SelectionSort е по-бърз защото извършва по-малко размени.
    Но това, което казахме до тук беше за най-лошия случай на InsertionSort. Ако гледаме средно InsertionSort е по-бърз в повечето случаи.
    Тъй като вътрешният цикъл ще приключва по-бързо, това ще спести доста време. Selection Sort винаги сканира целия масив.
*/
void InsertionSort(vector_t *v)
{
    for (int i = 1; i < getSize(v); i++)
    {
        int current = getAt(v, i);

        int j = i - 1;
        for (; j >= 0; j--)
        {
            if (current < getAt(v, j))
            {
                v->arr[j + 1] = v->arr[j];
            }
            else
            {
                break;
            }
        }
        v->arr[j + 1] = current;
    }
}

/*
    В крайна сметка и двата алгоритъма извършват от порядъка на N^2 операции и се считат за бавни. InsertionSort по-скоро бие SelectionSort.
    На практика дори InsertionSort е доста оптимален за малки масиви и дори бие някои от бързите алгоритми, които ще изучаваме по-натам.
*/

int main()
{
    vector_t *v = init_vector();
    push_back(v, 1);
    push_back(v, -15);
    push_back(v, 2);
    push_back(v, -7);
    push_back(v, 165);
    push_back(v, 5);
    push_back(v, 10);

    SelectionSort(v);
    printVector(v);

    vector_t *v2 = init_vector();
    push_back(v2, 1);
    push_back(v2, -15);
    push_back(v2, 2);
    push_back(v2, -7);
    push_back(v2, 165);
    push_back(v2, 5);
    push_back(v2, 10);

    InsertionSort(v2);
    printVector(v2);

    return 0;
}