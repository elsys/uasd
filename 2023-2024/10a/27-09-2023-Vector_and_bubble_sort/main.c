#include <stdio.h>
#include <stdlib.h>
#include "vector.h"

int main()
{
    vector_t *v = init_vector();

    push_back(v, 1);
    push_back(v, 2);
    push_back(v, 3);

    printVector(v);

    int poppedValue = pop(v);
    printVector(v);

    push_back(v, 5);
    push_back(v, -3);
    push_back(v, 0);
    push_back(v, -13);
    push_back(v, 15);

    printVector(v);

    printf("\n capacity - %d\n", v->capacity);

    /*
        Bubble Sort
        Един от най-простите алгоритми за сортиране. Работи като минава през масива
        и два по два сравнява елементите. Ако те не са в правилен ред ги размества.
        При едно обхождане на масива по тази схема максималният елемент ще отиде най-вдясно.
        Останалата част на масива все още не е сортирана съсигурност. За да гарантираме, че ще
        сортираме целия масив трябва да направим подобно обхождане общо N-1 пъти, където N е големината на масива.

        Две оптимизации, които можем да направим са
        - Ако при едно обхождане се окаже че не сме направили нито една размяна, то е ясно, че масивът е сортиран
            и може да прекъснем
        - При всяко следващо обхождане в дясната част на масива се трупат максималните елемент в сортиран ред. Тоест след първото
            обхождане е ясно, че последния елемент си е на място и не е нужно да правим последната проверка при второто обхождане.
            При третото обхождане вече последните два елемент са си на място и не е нужно да правим последните две и т.н.

        Gif демонстрация - https://commons.wikimedia.org/wiki/File:Bubble-sort.gif
    */

    for (int i = 0; i < getSize(v) - 1; i++)
    {
        int swapped = 0;
        for (int j = 0; j < getSize(v) - 1 - i; j++)
        {
            if (getAt(v, j) > getAt(v, j + 1))
            {
                int t = v->arr[j];
                v->arr[j] = v->arr[j + 1];
                v->arr[j + 1] = t;
                swapped = 1;
            }
        }

        if (!swapped)
        {
            break;
        }
    }

    printVector(v);
    clear(v);
    free(v);

    return 0;
}
