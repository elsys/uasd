# Упражнение 1

За задачите може да използвате вектор имплементацията от миналия час или ваша имплементация на вектор ако имате такава. Недейте тепърва да пишете нов вектор. За удобство имате кода за вектор в тази директория.

## Задача 1

Използвайки вектор имплементацията от миналия час реализирайте Selection Sort алгоритъма. Selection sort работи като условно разделя масива на две части. Сортирана лява част, която в началото е празна, и несортирана дясна, която в началото е целия масив. Обхожда несоритраната част на масива и намира най-малкия (или най-големия) елемент в нея и го разменя с първия елемент от несортиранта част. Така вече този елемент е част от сортираната част. След N повторения масива е сортиран.

Илюстрация:
![Selection Sort](./selection_sort.gif)

## Задача 2

Сортирайте два произволни вектора със Selection Sort. Съставете трети вектор, който съдържа елементите на предишните два по такъв начин, че той също да е в сортиран ред. Алгоритъмът трябва да работи така, че с едно обхождане на двата масива да получим директно сортиран трети. Тоест не искаме просто да направим произволен трети масив (например като закачим елементите на втория към края на първия) и към него отново да приложим Selection Sort.

## Задача 3

Измислите рекурсивна функция, която да реализира сума на елементите във вектор. Функцията трябва да има следната сигнатура:

```c
int vectorSum(vector_t *v, int currentIndex);
```

Примерно използване:

```c
vector_t* v = init_vector();
push_back(v, 5);
push_back(v, 6);
push_back(v, 7);

vectorSum(v, 0); // 18
```

## Задача 4 \*

Измислете рекурсивна функция

```c
void allVectorSums(vector_t *v, int currentIndex, int currentSum);
```

, която извежда на стандартния изход всички възможни суми на елементите в един вектор. Тоест в горния пример това са: <ul>

<li>0 - нито един елемент не се включва в сумата</li>
<li>5, 6, 7</li>
<li>5+6, 5+7, 6+7</li>
<li>5+6+7</li>
</ul>

Примерно извикване:

```c
allVectorSums(v, 0, 0); //0 7 6 13 5 12 11 18, реда няма значение
```
